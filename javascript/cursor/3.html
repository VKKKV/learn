<style>
  /**
   * Mouse Stalker (Custom Cursor) - Arch Edition (Light Theme Patch)
   */
  :root {
      --my-brand-color: #ff6b6b;
    --my-brand-rgb: 255, 107, 107;

    /* Hover 状态 - 稍微变亮，接近白色或高亮红 */
    --my-hover-color: #ffcccc;
    --my-hover-rgb: 255, 204, 204;

    --cursor-size: 30px;
  }

  /* 1. Global Cursor Hiding */
  body,
  a,
  button,
  input,
  textarea,
  .copy-btn {
    cursor: none !important;
  }

  /* 2. The Stalker */
  @media (any-hover: hover) {
    #mouse_stalker {
      pointer-events: none;
      position: fixed;
      top: 0;
      left: 0;
      width: var(--cursor-size);
      height: var(--cursor-size);

      background: rgba(var(--my-brand-rgb), 0.85);
      border: 4px solid var(--my-brand-color);

      border-radius: 50%;
      z-index: 99999;

      opacity: 0;
      transform: translate(-100px, -100px);

      will-change: transform;
      transform-origin: center center;
      transition:
        background-color 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94),
        border-color 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        border-width 0.1s ease;

        mix-blend-mode: difference;
    }

    /* 中心准心 */
    #mouse_stalker::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 4px;
      background-color: var(--my-brand-color);
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255, 255, 255, 1);
      z-index: 10;
    }

    /* 3. Hover State */
    #mouse_stalker.stalker_cursor_pointer {
      background: rgba(var(--my-hover-rgb), 0.4);
      border-color: var(--my-hover-color);
      border-width: 8px;
    }

    #mouse_stalker.stalker_cursor_pointer:before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border: 8px solid var(--my-hover-color);
      border-radius: 50%;
      animation: stalker_appeal 2s ease-out infinite;
    }

    @keyframes stalker_appeal {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(2.5);
      }
    }
  }

  #mouse_stalker.is_clicked {
    background: rgba(255, 0, 0, 0.4) !important;
    border-color: var(--click-color) !important;
    border-width: 3px !important;
  }

  @media (any-hover: none) {
    #mouse_stalker {
      display: none;
    }
  }
</style>

<div id="mouse_stalker"></div>

<script>
  (function () {
    const stalker = document.getElementById("mouse_stalker");
    if (!window.matchMedia("(any-hover: hover)").matches || !stalker) return;

    const config = {
      smooth: 0.233,
      scaleSmooth: 0.15,
      baseScale: 1,
      hoverScale: 1.8,
      clickScale: 0.7,
      offset: 15,
      stretchFactor: 0.04,
      maxStretch: 0.2,
      // Magnetic Force
      // 0.1 = Weak pull, 0.8 = Strong snap
      // 0.35 is the sweet spot for UI elements
      stickiness: 0.35,
    };

    let mouse = { x: -100, y: -100 }; // The target position for the circle
    let rawMouse = { x: -100, y: -100 }; // The ACTUAL mouse position
    let circle = { x: -100, y: -100, scale: 1, angle: 0 };
    let prevCircle = { x: -100, y: -100 };

    let activeTarget = null; // Currently hovered element (DOM Node)
    let isHovering = false;
    let isClicked = false;
    let firstMove = true;

    const resetStalker = () => {
      activeTarget = null;
      isHovering = false;
      stalker.classList.remove("stalker_cursor_pointer");
      stalker.classList.remove("is_clicked");
    };

    window.addEventListener("click", (e) => {
      const target = e.target.closest("a, button");
      if (target) {
        resetStalker();
      }
    });

    document.addEventListener("pjax:send", resetStalker); // PJAX 开始时
    document.addEventListener("pjax:complete", resetStalker); // PJAX 完成时
    window.addEventListener("popstate", resetStalker); // 浏览器的后退/前进按钮

    // Utility: Linear Interpolation
    const lerp = (start, end, factor) => start + (end - start) * factor;

    window.addEventListener("mousemove", (e) => {
      rawMouse.x = e.clientX;
      rawMouse.y = e.clientY;

      if (firstMove) {
        circle.x = mouse.x;
        circle.y = mouse.y;
        prevCircle.x = mouse.x;
        prevCircle.y = mouse.y;
        stalker.style.opacity = 1;
        firstMove = false;
      }

      // --- Magnetic Pull Effect Logic ---
      if (!activeTarget) {
        // Case 1: Free roaming - follow the mouse exactly
        mouse.x = rawMouse.x;
        mouse.y = rawMouse.y;
      } else {
        // Case 2: Magnetic Snapping
        // Calculate center of the target element
        const rect = activeTarget.getBoundingClientRect();

        // Determine snap point (Center for most, Left for Audio players?)
        const targetX =
          activeTarget.tagName === "AUDIO"
            ? rect.left + 20
            : rect.left + rect.width / 2;
        const targetY = rect.top + rect.height / 2;

        // Apply Magnetic Interpolation
        // Instead of going straight to the center, we blend the mouse pos and center
        mouse.x = lerp(rawMouse.x, targetX, config.stickiness);
        mouse.y = lerp(rawMouse.y, targetY, config.stickiness);
      }
    });

    // Click Detection (Tactile Feedback Input)
    window.addEventListener("mousedown", () => {
      isClicked = true;
      stalker.classList.add("is_clicked");
    });

    window.addEventListener("mouseup", () => {
      isClicked = false;
      stalker.classList.remove("is_clicked");
    });

    const hoverSelectors =
      "a, button, .toggle, #exturl, #post-title, .article-title, .nav-link, .copy-btn";

    window.addEventListener("mouseover", (e) => {
      const target = e.target.closest(hoverSelectors);
      if (target) {
        activeTarget = target; // Lock onto the target
        stalker.classList.add("stalker_cursor_pointer");
      }
    });

    window.addEventListener("mouseout", (e) => {
      // Only release if we are leaving the currently active target
      const target = e.target.closest(hoverSelectors);
      if (target === activeTarget) {
        activeTarget = null; // Release lock
        stalker.classList.remove("stalker_cursor_pointer");
      }
    });

    function animate() {
      circle.x = lerp(circle.x, mouse.x, config.smooth);
      circle.y = lerp(circle.y, mouse.y, config.smooth);

      const dx = circle.x - prevCircle.x;
      const dy = circle.y - prevCircle.y;
      const speed = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx);

      const stretch = Math.min(speed * config.stretchFactor, config.maxStretch);
      const scaleX = 1 + stretch;
      const scaleY = 1 - stretch;

      const targetBaseScale = isHovering ? config.hoverScale : config.baseScale;
      circle.scale = lerp(circle.scale, targetBaseScale, config.scaleSmooth);

      stalker.style.transform = `
      translate3d(${circle.x - config.offset}px, ${circle.y - config.offset}px, 0)
      rotate(${angle}rad)
      scale(${scaleX * circle.scale}, ${scaleY * circle.scale})
    `;
      prevCircle.x = circle.x;
      prevCircle.y = circle.y;
      requestAnimationFrame(animate);
    }
    animate();
  })();
</script>
